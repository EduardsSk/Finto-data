PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX ysa: <http://www.yso.fi/onto/ysa/>
PREFIX yso: <http://www.yso.fi/onto/yso/>
PREFIX ysa-meta: <http://www.yso.fi/onto/ysa-meta/>
PREFIX yso-meta: <http://www.yso.fi/onto/yso-meta/2007-03-02/>
PREFIX yso-update: <http://www.yso.fi/onto/yso-update/>
PREFIX dc: <http://purl.org/dc/elements/1.1/> 
PREFIX dct: <http://purl.org/dc/terms/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX om: <http://www.yso.fi/onto/yso-peilaus/2007-03-02/>
PREFIX dsv: <http://purl.org/iso25964/DataSet/Versioning#>
PREFIX xhv: <http://www.w3.org/1999/xhtml/vocab#>
PREFIX sh: <http://purl.org/skos-history/>
PREFIX sd: <http://www.w3.org/ns/sparql-service-description#>
PREFIX dcterms: <http://purl.org/dc/terms/>

CONSTRUCT {
  ?newc om:definedConcept ?c .
  ?newc a yso-meta:Concept .
  ?newc skos:prefLabel ?pref .
  ?newc yso-meta:oldLabel ?alt .
  ?newc skos:note ?note .
  ?newc yso-meta:ysaSource ?source .
  ?newc yso-meta:hasThematicGroup ?ysogroup .
  ?newc rdfs:subClassOf ?ysobroader .
  ?newc rdfs:subClassOf yso-update:uudet .
  ?ysonarrower rdfs:subClassOf ?newc .
  ?newc yso-meta:associativeRelation ?ysorelated .
  ?ysorelated yso-meta:associativeRelation ?newc .
}
WHERE {
  {
    SELECT ?c ?newVersionGraph
    WHERE {
      # parameters
      VALUES ( ?versionHistoryGraph ?conceptType ?oldVersion ?newVersion ) {
        ( <http://www.yso.fi/onto/ysa/version> skos:Concept  "2014-04-10" "2015-11-01" )
      }
      SERVICE <http://sparql.dev.finto.fi/skos-history/sparql> {
        GRAPH ?versionHistoryGraph {
          # get the current and the previous version as default versions
          ?versionset dsv:currentVersionRecord/xhv:prev/dc:identifier ?previousVersion .
          ?versionset dsv:currentVersionRecord/dc:identifier ?latestVersion .
          # select the versions to actually use
          BIND(coalesce(?oldVersion, ?previousVersion) AS ?oldVersionSelected)
          BIND(coalesce(?newVersion, ?latestVersion) AS ?newVersionSelected)
          # get the delta and via that the relevant graphs
          ?delta a sh:SchemeDelta ;
            sh:deltaFrom/dc:identifier ?oldVersionSelected ;
            sh:deltaTo/dc:identifier ?newVersionSelected ;
            sh:deltaFrom/sh:usingNamedGraph/sd:name ?oldVersionGraph ;
            sh:deltaTo/sh:usingNamedGraph/sd:name ?newVersionGraph ;
            dcterms:hasPart ?insertions ;
            dcterms:hasPart ?deletions .
          ?deletions a sh:SchemeDeltaDeletions ;
            sh:usingNamedGraph/sd:name ?deletionsGraph .
          ?insertions a sh:SchemeDeltaInsertions ;
            sh:usingNamedGraph/sd:name ?insertionsGraph .
        }
        GRAPH ?newVersionGraph {
          ?c a skos:Concept .
          FILTER NOT EXISTS { ?c a ysa-meta:GeographicalConcept }
          # optimization: don't return concepts which have a match in YSO
          FILTER NOT EXISTS {
	    ?c skos:closeMatch ?ysoc
            FILTER (STRSTARTS(STR(?ysoc), STR(yso:)))
          }
        }
      }
      FILTER NOT EXISTS {
        ?ysoc om:definedConcept ?c .
      }
    }
  }
  BIND(IRI(REPLACE(STR(?c), STR(ysa:), STR(yso:))) as ?newc)
  SERVICE <http://sparql.dev.finto.fi/skos-history/sparql> {
    GRAPH ?newVersionGraph {
      ?c skos:prefLabel ?pref .
      OPTIONAL { ?c skos:altLabel ?alt }
      OPTIONAL { ?c skos:scopeNote|skos:note ?note }
      OPTIONAL { ?c dc:source ?source }
      OPTIONAL { ?ysagroup skos:member ?c }

      # broader, narrower, related
      OPTIONAL { ?c skos:broader ?ysab }
      BIND(IF(BOUND(?ysab), ?ysab, '') AS ?broader)
      OPTIONAL { ?c skos:narrower ?ysan }
      BIND(IF(BOUND(?ysan), ?ysan, '') AS ?narrower)
      OPTIONAL { ?c skos:related ?ysar }
      BIND(IF(BOUND(?ysar), ?ysar, '') AS ?related)
    }  
  }
  OPTIONAL { 
    BIND(IF(BOUND(?ysagroup), ?ysagroup, '') AS ?realysagroup)
    ?ysogroup om:definedConcept ?realysagroup
  }
  # must check whether an equivalent target concept already exists; if not, use a newly minted URI base on YSA localname
  OPTIONAL { ?ysob om:definedConcept ?broader }
  BIND(IF(BOUND(?ysob), ?ysob, IF(isIRI(?broader), IRI(REPLACE(STR(?broader), STR(ysa:), STR(yso:))), ?unbound)) AS ?ysobroader)
  OPTIONAL { ?yson om:definedConcept ?narrower }
  BIND(IF(BOUND(?yson), ?yson, IF(isIRI(?narrower), IRI(REPLACE(STR(?narrower), STR(ysa:), STR(yso:))), ?unbound)) AS ?ysonarrower)
  OPTIONAL { ?ysor om:definedConcept ?related }
  BIND(IF(BOUND(?ysor), ?ysor, IF(isIRI(?related), IRI(REPLACE(STR(?related), STR(ysa:), STR(yso:))), ?unbound)) AS ?ysorelated)
}
